//
//  MessageContent.swift
//  tl2swift
//
//  Created by Code Generator
//

import Foundation

/// Contains the content of a message
internal enum MessageContent: Codable {
    /// A text message
    case messageText(MessageText)

    /// An animation message (GIF-style).
    case messageAnimation(MessageAnimation)

    /// An audio message
    case messageAudio(MessageAudio)

    /// A document message (general file)
    case messageDocument(MessageDocument)

    /// A photo message
    case messagePhoto(MessagePhoto)

    /// An expired photo message (self-destructed after TTL has elapsed)
    case messageExpiredPhoto

    /// A sticker message
    case messageSticker(MessageSticker)

    /// A video message
    case messageVideo(MessageVideo)

    /// An expired video message (self-destructed after TTL has elapsed)
    case messageExpiredVideo

    /// A video note message
    case messageVideoNote(MessageVideoNote)

    /// A voice note message
    case messageVoiceNote(MessageVoiceNote)

    /// A message with a location
    case messageLocation(MessageLocation)

    /// A message with information about a venue
    case messageVenue(MessageVenue)

    /// A message with a user contact
    case messageContact(MessageContact)

    /// A dice message. The dice value is randomly generated by the server
    case messageDice(MessageDice)

    /// A message with a game
    case messageGame(MessageGame)

    /// A message with a poll
    case messagePoll(MessagePoll)

    /// A message with an invoice from a bot
    case messageInvoice(MessageInvoice)

    /// A message with information about an ended call
    case messageCall(MessageCall)

    /// A new voice chat was scheduled
    case messageVoiceChatScheduled(MessageVoiceChatScheduled)

    /// A newly created voice chat
    case messageVoiceChatStarted(MessageVoiceChatStarted)

    /// A message with information about an ended voice chat
    case messageVoiceChatEnded(MessageVoiceChatEnded)

    /// A message with information about an invite to a voice chat
    case messageInviteVoiceChatParticipants(MessageInviteVoiceChatParticipants)

    /// A newly created basic group
    case messageBasicGroupChatCreate(MessageBasicGroupChatCreate)

    /// A newly created supergroup or channel
    case messageSupergroupChatCreate(MessageSupergroupChatCreate)

    /// An updated chat title
    case messageChatChangeTitle(MessageChatChangeTitle)

    /// An updated chat photo
    case messageChatChangePhoto(MessageChatChangePhoto)

    /// A deleted chat photo
    case messageChatDeletePhoto

    /// New chat members were added
    case messageChatAddMembers(MessageChatAddMembers)

    /// A new member joined the chat by invite link
    case messageChatJoinByLink

    /// A chat member was deleted
    case messageChatDeleteMember(MessageChatDeleteMember)

    /// A basic group was upgraded to a supergroup and was deactivated as the result
    case messageChatUpgradeTo(MessageChatUpgradeTo)

    /// A supergroup has been created from a basic group
    case messageChatUpgradeFrom(MessageChatUpgradeFrom)

    /// A message has been pinned
    case messagePinMessage(MessagePinMessage)

    /// A screenshot of a message in the chat has been taken
    case messageScreenshotTaken

    /// The TTL (Time To Live) setting for messages in the chat has been changed
    case messageChatSetTtl(MessageChatSetTtl)

    /// A non-standard action has happened in the chat
    case messageCustomServiceAction(MessageCustomServiceAction)

    /// A new high score was achieved in a game
    case messageGameScore(MessageGameScore)

    /// A payment has been completed
    case messagePaymentSuccessful(MessagePaymentSuccessful)

    /// A payment has been completed; for bots only
    case messagePaymentSuccessfulBot(MessagePaymentSuccessfulBot)

    /// A contact has registered with Telegram
    case messageContactRegistered

    /// The current user has connected a website by logging in using Telegram Login Widget on it
    case messageWebsiteConnected(MessageWebsiteConnected)

    /// Telegram Passport data has been sent
    case messagePassportDataSent(MessagePassportDataSent)

    /// Telegram Passport data has been received; for bots only
    case messagePassportDataReceived(MessagePassportDataReceived)

    /// A user in the chat came within proximity alert range
    case messageProximityAlertTriggered(MessageProximityAlertTriggered)

    /// Message content that is not supported in the current TDLib version
    case messageUnsupported

    private enum Kind: String, Codable {
        case messageText
        case messageAnimation
        case messageAudio
        case messageDocument
        case messagePhoto
        case messageExpiredPhoto
        case messageSticker
        case messageVideo
        case messageExpiredVideo
        case messageVideoNote
        case messageVoiceNote
        case messageLocation
        case messageVenue
        case messageContact
        case messageDice
        case messageGame
        case messagePoll
        case messageInvoice
        case messageCall
        case messageVoiceChatScheduled
        case messageVoiceChatStarted
        case messageVoiceChatEnded
        case messageInviteVoiceChatParticipants
        case messageBasicGroupChatCreate
        case messageSupergroupChatCreate
        case messageChatChangeTitle
        case messageChatChangePhoto
        case messageChatDeletePhoto
        case messageChatAddMembers
        case messageChatJoinByLink
        case messageChatDeleteMember
        case messageChatUpgradeTo
        case messageChatUpgradeFrom
        case messagePinMessage
        case messageScreenshotTaken
        case messageChatSetTtl
        case messageCustomServiceAction
        case messageGameScore
        case messagePaymentSuccessful
        case messagePaymentSuccessfulBot
        case messageContactRegistered
        case messageWebsiteConnected
        case messagePassportDataSent
        case messagePassportDataReceived
        case messageProximityAlertTriggered
        case messageUnsupported
    }

    internal init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: DtoCodingKeys.self)
        let type = try container.decode(Kind.self, forKey: .type)
        switch type {
        case .messageText:
            let value = try MessageText(from: decoder)
            self = .messageText(value)
        case .messageAnimation:
            let value = try MessageAnimation(from: decoder)
            self = .messageAnimation(value)
        case .messageAudio:
            let value = try MessageAudio(from: decoder)
            self = .messageAudio(value)
        case .messageDocument:
            let value = try MessageDocument(from: decoder)
            self = .messageDocument(value)
        case .messagePhoto:
            let value = try MessagePhoto(from: decoder)
            self = .messagePhoto(value)
        case .messageExpiredPhoto:
            self = .messageExpiredPhoto
        case .messageSticker:
            let value = try MessageSticker(from: decoder)
            self = .messageSticker(value)
        case .messageVideo:
            let value = try MessageVideo(from: decoder)
            self = .messageVideo(value)
        case .messageExpiredVideo:
            self = .messageExpiredVideo
        case .messageVideoNote:
            let value = try MessageVideoNote(from: decoder)
            self = .messageVideoNote(value)
        case .messageVoiceNote:
            let value = try MessageVoiceNote(from: decoder)
            self = .messageVoiceNote(value)
        case .messageLocation:
            let value = try MessageLocation(from: decoder)
            self = .messageLocation(value)
        case .messageVenue:
            let value = try MessageVenue(from: decoder)
            self = .messageVenue(value)
        case .messageContact:
            let value = try MessageContact(from: decoder)
            self = .messageContact(value)
        case .messageDice:
            let value = try MessageDice(from: decoder)
            self = .messageDice(value)
        case .messageGame:
            let value = try MessageGame(from: decoder)
            self = .messageGame(value)
        case .messagePoll:
            let value = try MessagePoll(from: decoder)
            self = .messagePoll(value)
        case .messageInvoice:
            let value = try MessageInvoice(from: decoder)
            self = .messageInvoice(value)
        case .messageCall:
            let value = try MessageCall(from: decoder)
            self = .messageCall(value)
        case .messageVoiceChatScheduled:
            let value = try MessageVoiceChatScheduled(from: decoder)
            self = .messageVoiceChatScheduled(value)
        case .messageVoiceChatStarted:
            let value = try MessageVoiceChatStarted(from: decoder)
            self = .messageVoiceChatStarted(value)
        case .messageVoiceChatEnded:
            let value = try MessageVoiceChatEnded(from: decoder)
            self = .messageVoiceChatEnded(value)
        case .messageInviteVoiceChatParticipants:
            let value = try MessageInviteVoiceChatParticipants(from: decoder)
            self = .messageInviteVoiceChatParticipants(value)
        case .messageBasicGroupChatCreate:
            let value = try MessageBasicGroupChatCreate(from: decoder)
            self = .messageBasicGroupChatCreate(value)
        case .messageSupergroupChatCreate:
            let value = try MessageSupergroupChatCreate(from: decoder)
            self = .messageSupergroupChatCreate(value)
        case .messageChatChangeTitle:
            let value = try MessageChatChangeTitle(from: decoder)
            self = .messageChatChangeTitle(value)
        case .messageChatChangePhoto:
            let value = try MessageChatChangePhoto(from: decoder)
            self = .messageChatChangePhoto(value)
        case .messageChatDeletePhoto:
            self = .messageChatDeletePhoto
        case .messageChatAddMembers:
            let value = try MessageChatAddMembers(from: decoder)
            self = .messageChatAddMembers(value)
        case .messageChatJoinByLink:
            self = .messageChatJoinByLink
        case .messageChatDeleteMember:
            let value = try MessageChatDeleteMember(from: decoder)
            self = .messageChatDeleteMember(value)
        case .messageChatUpgradeTo:
            let value = try MessageChatUpgradeTo(from: decoder)
            self = .messageChatUpgradeTo(value)
        case .messageChatUpgradeFrom:
            let value = try MessageChatUpgradeFrom(from: decoder)
            self = .messageChatUpgradeFrom(value)
        case .messagePinMessage:
            let value = try MessagePinMessage(from: decoder)
            self = .messagePinMessage(value)
        case .messageScreenshotTaken:
            self = .messageScreenshotTaken
        case .messageChatSetTtl:
            let value = try MessageChatSetTtl(from: decoder)
            self = .messageChatSetTtl(value)
        case .messageCustomServiceAction:
            let value = try MessageCustomServiceAction(from: decoder)
            self = .messageCustomServiceAction(value)
        case .messageGameScore:
            let value = try MessageGameScore(from: decoder)
            self = .messageGameScore(value)
        case .messagePaymentSuccessful:
            let value = try MessagePaymentSuccessful(from: decoder)
            self = .messagePaymentSuccessful(value)
        case .messagePaymentSuccessfulBot:
            let value = try MessagePaymentSuccessfulBot(from: decoder)
            self = .messagePaymentSuccessfulBot(value)
        case .messageContactRegistered:
            self = .messageContactRegistered
        case .messageWebsiteConnected:
            let value = try MessageWebsiteConnected(from: decoder)
            self = .messageWebsiteConnected(value)
        case .messagePassportDataSent:
            let value = try MessagePassportDataSent(from: decoder)
            self = .messagePassportDataSent(value)
        case .messagePassportDataReceived:
            let value = try MessagePassportDataReceived(from: decoder)
            self = .messagePassportDataReceived(value)
        case .messageProximityAlertTriggered:
            let value = try MessageProximityAlertTriggered(from: decoder)
            self = .messageProximityAlertTriggered(value)
        case .messageUnsupported:
            self = .messageUnsupported
        }
    }

    internal func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: DtoCodingKeys.self)
        switch self {
        case let .messageText(value):
            try container.encode(Kind.messageText, forKey: .type)
            try value.encode(to: encoder)
        case let .messageAnimation(value):
            try container.encode(Kind.messageAnimation, forKey: .type)
            try value.encode(to: encoder)
        case let .messageAudio(value):
            try container.encode(Kind.messageAudio, forKey: .type)
            try value.encode(to: encoder)
        case let .messageDocument(value):
            try container.encode(Kind.messageDocument, forKey: .type)
            try value.encode(to: encoder)
        case let .messagePhoto(value):
            try container.encode(Kind.messagePhoto, forKey: .type)
            try value.encode(to: encoder)
        case .messageExpiredPhoto:
            try container.encode(Kind.messageExpiredPhoto, forKey: .type)
        case let .messageSticker(value):
            try container.encode(Kind.messageSticker, forKey: .type)
            try value.encode(to: encoder)
        case let .messageVideo(value):
            try container.encode(Kind.messageVideo, forKey: .type)
            try value.encode(to: encoder)
        case .messageExpiredVideo:
            try container.encode(Kind.messageExpiredVideo, forKey: .type)
        case let .messageVideoNote(value):
            try container.encode(Kind.messageVideoNote, forKey: .type)
            try value.encode(to: encoder)
        case let .messageVoiceNote(value):
            try container.encode(Kind.messageVoiceNote, forKey: .type)
            try value.encode(to: encoder)
        case let .messageLocation(value):
            try container.encode(Kind.messageLocation, forKey: .type)
            try value.encode(to: encoder)
        case let .messageVenue(value):
            try container.encode(Kind.messageVenue, forKey: .type)
            try value.encode(to: encoder)
        case let .messageContact(value):
            try container.encode(Kind.messageContact, forKey: .type)
            try value.encode(to: encoder)
        case let .messageDice(value):
            try container.encode(Kind.messageDice, forKey: .type)
            try value.encode(to: encoder)
        case let .messageGame(value):
            try container.encode(Kind.messageGame, forKey: .type)
            try value.encode(to: encoder)
        case let .messagePoll(value):
            try container.encode(Kind.messagePoll, forKey: .type)
            try value.encode(to: encoder)
        case let .messageInvoice(value):
            try container.encode(Kind.messageInvoice, forKey: .type)
            try value.encode(to: encoder)
        case let .messageCall(value):
            try container.encode(Kind.messageCall, forKey: .type)
            try value.encode(to: encoder)
        case let .messageVoiceChatScheduled(value):
            try container.encode(Kind.messageVoiceChatScheduled, forKey: .type)
            try value.encode(to: encoder)
        case let .messageVoiceChatStarted(value):
            try container.encode(Kind.messageVoiceChatStarted, forKey: .type)
            try value.encode(to: encoder)
        case let .messageVoiceChatEnded(value):
            try container.encode(Kind.messageVoiceChatEnded, forKey: .type)
            try value.encode(to: encoder)
        case let .messageInviteVoiceChatParticipants(value):
            try container.encode(Kind.messageInviteVoiceChatParticipants, forKey: .type)
            try value.encode(to: encoder)
        case let .messageBasicGroupChatCreate(value):
            try container.encode(Kind.messageBasicGroupChatCreate, forKey: .type)
            try value.encode(to: encoder)
        case let .messageSupergroupChatCreate(value):
            try container.encode(Kind.messageSupergroupChatCreate, forKey: .type)
            try value.encode(to: encoder)
        case let .messageChatChangeTitle(value):
            try container.encode(Kind.messageChatChangeTitle, forKey: .type)
            try value.encode(to: encoder)
        case let .messageChatChangePhoto(value):
            try container.encode(Kind.messageChatChangePhoto, forKey: .type)
            try value.encode(to: encoder)
        case .messageChatDeletePhoto:
            try container.encode(Kind.messageChatDeletePhoto, forKey: .type)
        case let .messageChatAddMembers(value):
            try container.encode(Kind.messageChatAddMembers, forKey: .type)
            try value.encode(to: encoder)
        case .messageChatJoinByLink:
            try container.encode(Kind.messageChatJoinByLink, forKey: .type)
        case let .messageChatDeleteMember(value):
            try container.encode(Kind.messageChatDeleteMember, forKey: .type)
            try value.encode(to: encoder)
        case let .messageChatUpgradeTo(value):
            try container.encode(Kind.messageChatUpgradeTo, forKey: .type)
            try value.encode(to: encoder)
        case let .messageChatUpgradeFrom(value):
            try container.encode(Kind.messageChatUpgradeFrom, forKey: .type)
            try value.encode(to: encoder)
        case let .messagePinMessage(value):
            try container.encode(Kind.messagePinMessage, forKey: .type)
            try value.encode(to: encoder)
        case .messageScreenshotTaken:
            try container.encode(Kind.messageScreenshotTaken, forKey: .type)
        case let .messageChatSetTtl(value):
            try container.encode(Kind.messageChatSetTtl, forKey: .type)
            try value.encode(to: encoder)
        case let .messageCustomServiceAction(value):
            try container.encode(Kind.messageCustomServiceAction, forKey: .type)
            try value.encode(to: encoder)
        case let .messageGameScore(value):
            try container.encode(Kind.messageGameScore, forKey: .type)
            try value.encode(to: encoder)
        case let .messagePaymentSuccessful(value):
            try container.encode(Kind.messagePaymentSuccessful, forKey: .type)
            try value.encode(to: encoder)
        case let .messagePaymentSuccessfulBot(value):
            try container.encode(Kind.messagePaymentSuccessfulBot, forKey: .type)
            try value.encode(to: encoder)
        case .messageContactRegistered:
            try container.encode(Kind.messageContactRegistered, forKey: .type)
        case let .messageWebsiteConnected(value):
            try container.encode(Kind.messageWebsiteConnected, forKey: .type)
            try value.encode(to: encoder)
        case let .messagePassportDataSent(value):
            try container.encode(Kind.messagePassportDataSent, forKey: .type)
            try value.encode(to: encoder)
        case let .messagePassportDataReceived(value):
            try container.encode(Kind.messagePassportDataReceived, forKey: .type)
            try value.encode(to: encoder)
        case let .messageProximityAlertTriggered(value):
            try container.encode(Kind.messageProximityAlertTriggered, forKey: .type)
            try value.encode(to: encoder)
        case .messageUnsupported:
            try container.encode(Kind.messageUnsupported, forKey: .type)
        }
    }
}

/// A text message
internal struct MessageText: Codable {
    /// Text of the message
    internal let text: FormattedText

    /// A preview of the web page that's mentioned in the text; may be null
    internal let webPage: WebPage?

    internal init(
        text: FormattedText,
        webPage: WebPage?
    ) {
        self.text = text
        self.webPage = webPage
    }
}

/// An animation message (GIF-style).
internal struct MessageAnimation: Codable {
    /// The animation description
    internal let animation: Animation

    /// Animation caption
    internal let caption: FormattedText

    /// True, if the animation thumbnail must be blurred and the animation must be shown only while tapped
    internal let isSecret: Bool

    internal init(
        animation: Animation,
        caption: FormattedText,
        isSecret: Bool
    ) {
        self.animation = animation
        self.caption = caption
        self.isSecret = isSecret
    }
}

/// An audio message
internal struct MessageAudio: Codable {
    /// The audio description
    internal let audio: Audio

    /// Audio caption
    internal let caption: FormattedText

    internal init(
        audio: Audio,
        caption: FormattedText
    ) {
        self.audio = audio
        self.caption = caption
    }
}

/// A document message (general file)
internal struct MessageDocument: Codable {
    /// Document caption
    internal let caption: FormattedText

    /// The document description
    internal let document: Document

    internal init(
        caption: FormattedText,
        document: Document
    ) {
        self.caption = caption
        self.document = document
    }
}

/// A photo message
internal struct MessagePhoto: Codable {
    /// Photo caption
    internal let caption: FormattedText

    /// True, if the photo must be blurred and must be shown only while tapped
    internal let isSecret: Bool

    /// The photo description
    internal let photo: Photo

    internal init(
        caption: FormattedText,
        isSecret: Bool,
        photo: Photo
    ) {
        self.caption = caption
        self.isSecret = isSecret
        self.photo = photo
    }
}

/// A sticker message
internal struct MessageSticker: Codable {
    /// The sticker description
    internal let sticker: Sticker

    internal init(sticker: Sticker) {
        self.sticker = sticker
    }
}

/// A video message
internal struct MessageVideo: Codable {
    /// Video caption
    internal let caption: FormattedText

    /// True, if the video thumbnail must be blurred and the video must be shown only while tapped
    internal let isSecret: Bool

    /// The video description
    internal let video: Video

    internal init(
        caption: FormattedText,
        isSecret: Bool,
        video: Video
    ) {
        self.caption = caption
        self.isSecret = isSecret
        self.video = video
    }
}

/// A video note message
internal struct MessageVideoNote: Codable {
    /// True, if the video note thumbnail must be blurred and the video note must be shown only while tapped
    internal let isSecret: Bool

    /// True, if at least one of the recipients has viewed the video note
    internal let isViewed: Bool

    /// The video note description
    internal let videoNote: VideoNote

    internal init(
        isSecret: Bool,
        isViewed: Bool,
        videoNote: VideoNote
    ) {
        self.isSecret = isSecret
        self.isViewed = isViewed
        self.videoNote = videoNote
    }
}

/// A voice note message
internal struct MessageVoiceNote: Codable {
    /// Voice note caption
    internal let caption: FormattedText

    /// True, if at least one of the recipients has listened to the voice note
    internal let isListened: Bool

    /// The voice note description
    internal let voiceNote: VoiceNote

    internal init(
        caption: FormattedText,
        isListened: Bool,
        voiceNote: VoiceNote
    ) {
        self.caption = caption
        self.isListened = isListened
        self.voiceNote = voiceNote
    }
}

/// A message with a location
internal struct MessageLocation: Codable {
    /// Left time for which the location can be updated, in seconds. updateMessageContent is not sent when this field changes
    internal let expiresIn: Int

    /// For live locations, a direction in which the location moves, in degrees; 1-360. If 0 the direction is unknown
    internal let heading: Int

    /// Time relative to the message send date, for which the location can be updated, in seconds
    internal let livePeriod: Int

    /// The location description
    internal let location: Location

    /// For live locations, a maximum distance to another chat member for proximity alerts, in meters (0-100000). 0 if the notification is disabled. Available only for the message sender
    internal let proximityAlertRadius: Int

    internal init(
        expiresIn: Int,
        heading: Int,
        livePeriod: Int,
        location: Location,
        proximityAlertRadius: Int
    ) {
        self.expiresIn = expiresIn
        self.heading = heading
        self.livePeriod = livePeriod
        self.location = location
        self.proximityAlertRadius = proximityAlertRadius
    }
}

/// A message with information about a venue
internal struct MessageVenue: Codable {
    /// The venue description
    internal let venue: Venue

    internal init(venue: Venue) {
        self.venue = venue
    }
}

/// A message with a user contact
internal struct MessageContact: Codable {
    /// The contact description
    internal let contact: Contact

    internal init(contact: Contact) {
        self.contact = contact
    }
}

/// A dice message. The dice value is randomly generated by the server
internal struct MessageDice: Codable {
    /// Emoji on which the dice throw animation is based
    internal let emoji: String

    /// The animated stickers with the final dice animation; may be null if unknown. updateMessageContent will be sent when the sticker became known
    internal let finalState: DiceStickers?

    /// The animated stickers with the initial dice animation; may be null if unknown. updateMessageContent will be sent when the sticker became known
    internal let initialState: DiceStickers?

    /// Number of frame after which a success animation like a shower of confetti needs to be shown on updateMessageSendSucceeded
    internal let successAnimationFrameNumber: Int

    /// The dice value. If the value is 0, the dice don't have final state yet
    internal let value: Int

    internal init(
        emoji: String,
        finalState: DiceStickers?,
        initialState: DiceStickers?,
        successAnimationFrameNumber: Int,
        value: Int
    ) {
        self.emoji = emoji
        self.finalState = finalState
        self.initialState = initialState
        self.successAnimationFrameNumber = successAnimationFrameNumber
        self.value = value
    }
}

/// A message with a game
internal struct MessageGame: Codable {
    /// The game description
    internal let game: Game

    internal init(game: Game) {
        self.game = game
    }
}

/// A message with a poll
internal struct MessagePoll: Codable {
    /// The poll description
    internal let poll: Poll

    internal init(poll: Poll) {
        self.poll = poll
    }
}

/// A message with an invoice from a bot
internal struct MessageInvoice: Codable {
    /// Currency for the product price
    internal let currency: String

    internal let description: String

    /// True, if the invoice is a test invoice
    internal let isTest: Bool

    /// True, if the shipping address should be specified
    internal let needShippingAddress: Bool

    /// Product photo; may be null
    internal let photo: Photo?

    /// The identifier of the message with the receipt, after the product has been purchased
    internal let receiptMessageId: Int64

    /// Unique invoice bot start_parameter. To share an invoice use the URL https://t.me/{bot_username}?start={start_parameter}
    internal let startParameter: String

    /// Product title
    internal let title: String

    /// Product total price in the smallest units of the currency
    internal let totalAmount: Int64

    internal init(
        currency: String,
        description: String,
        isTest: Bool,
        needShippingAddress: Bool,
        photo: Photo?,
        receiptMessageId: Int64,
        startParameter: String,
        title: String,
        totalAmount: Int64
    ) {
        self.currency = currency
        self.description = description
        self.isTest = isTest
        self.needShippingAddress = needShippingAddress
        self.photo = photo
        self.receiptMessageId = receiptMessageId
        self.startParameter = startParameter
        self.title = title
        self.totalAmount = totalAmount
    }
}

/// A message with information about an ended call
internal struct MessageCall: Codable {
    /// Reason why the call was discarded
    internal let discardReason: CallDiscardReason

    /// Call duration, in seconds
    internal let duration: Int

    /// True, if the call was a video call
    internal let isVideo: Bool

    internal init(
        discardReason: CallDiscardReason,
        duration: Int,
        isVideo: Bool
    ) {
        self.discardReason = discardReason
        self.duration = duration
        self.isVideo = isVideo
    }
}

/// A new voice chat was scheduled
internal struct MessageVoiceChatScheduled: Codable {
    /// Identifier of the voice chat. The voice chat can be received through the method getGroupCall
    internal let groupCallId: Int

    /// Point in time (Unix timestamp) when the group call is supposed to be started by an administrator
    internal let startDate: Int

    internal init(
        groupCallId: Int,
        startDate: Int
    ) {
        self.groupCallId = groupCallId
        self.startDate = startDate
    }
}

/// A newly created voice chat
internal struct MessageVoiceChatStarted: Codable {
    /// Identifier of the voice chat. The voice chat can be received through the method getGroupCall
    internal let groupCallId: Int

    internal init(groupCallId: Int) {
        self.groupCallId = groupCallId
    }
}

/// A message with information about an ended voice chat
internal struct MessageVoiceChatEnded: Codable {
    /// Call duration
    internal let duration: Int

    internal init(duration: Int) {
        self.duration = duration
    }
}

/// A message with information about an invite to a voice chat
internal struct MessageInviteVoiceChatParticipants: Codable {
    /// Identifier of the voice chat. The voice chat can be received through the method getGroupCall
    internal let groupCallId: Int

    /// Invited user identifiers
    internal let userIds: [Int]

    internal init(
        groupCallId: Int,
        userIds: [Int]
    ) {
        self.groupCallId = groupCallId
        self.userIds = userIds
    }
}

/// A newly created basic group
internal struct MessageBasicGroupChatCreate: Codable {
    /// User identifiers of members in the basic group
    internal let memberUserIds: [Int]

    /// Title of the basic group
    internal let title: String

    internal init(
        memberUserIds: [Int],
        title: String
    ) {
        self.memberUserIds = memberUserIds
        self.title = title
    }
}

/// A newly created supergroup or channel
internal struct MessageSupergroupChatCreate: Codable {
    /// Title of the supergroup or channel
    internal let title: String

    internal init(title: String) {
        self.title = title
    }
}

/// An updated chat title
internal struct MessageChatChangeTitle: Codable {
    /// New chat title
    internal let title: String

    internal init(title: String) {
        self.title = title
    }
}

/// An updated chat photo
internal struct MessageChatChangePhoto: Codable {
    /// New chat photo
    internal let photo: ChatPhoto

    internal init(photo: ChatPhoto) {
        self.photo = photo
    }
}

/// New chat members were added
internal struct MessageChatAddMembers: Codable {
    /// User identifiers of the new members
    internal let memberUserIds: [Int]

    internal init(memberUserIds: [Int]) {
        self.memberUserIds = memberUserIds
    }
}

/// A chat member was deleted
internal struct MessageChatDeleteMember: Codable {
    /// User identifier of the deleted chat member
    internal let userId: Int

    internal init(userId: Int) {
        self.userId = userId
    }
}

/// A basic group was upgraded to a supergroup and was deactivated as the result
internal struct MessageChatUpgradeTo: Codable {
    /// Identifier of the supergroup to which the basic group was upgraded
    internal let supergroupId: Int

    internal init(supergroupId: Int) {
        self.supergroupId = supergroupId
    }
}

/// A supergroup has been created from a basic group
internal struct MessageChatUpgradeFrom: Codable {
    /// The identifier of the original basic group
    internal let basicGroupId: Int

    /// Title of the newly created supergroup
    internal let title: String

    internal init(
        basicGroupId: Int,
        title: String
    ) {
        self.basicGroupId = basicGroupId
        self.title = title
    }
}

/// A message has been pinned
internal struct MessagePinMessage: Codable {
    /// Identifier of the pinned message, can be an identifier of a deleted message or 0
    internal let messageId: Int64

    internal init(messageId: Int64) {
        self.messageId = messageId
    }
}

/// The TTL (Time To Live) setting for messages in the chat has been changed
internal struct MessageChatSetTtl: Codable {
    /// New message TTL setting
    internal let ttl: Int

    internal init(ttl: Int) {
        self.ttl = ttl
    }
}

/// A non-standard action has happened in the chat
internal struct MessageCustomServiceAction: Codable {
    /// Message text to be shown in the chat
    internal let text: String

    internal init(text: String) {
        self.text = text
    }
}

/// A new high score was achieved in a game
internal struct MessageGameScore: Codable {
    /// Identifier of the game; may be different from the games presented in the message with the game
    internal let gameId: TdInt64

    /// Identifier of the message with the game, can be an identifier of a deleted message
    internal let gameMessageId: Int64

    /// New score
    internal let score: Int

    internal init(
        gameId: TdInt64,
        gameMessageId: Int64,
        score: Int
    ) {
        self.gameId = gameId
        self.gameMessageId = gameMessageId
        self.score = score
    }
}

/// A payment has been completed
internal struct MessagePaymentSuccessful: Codable {
    /// Currency for the price of the product
    internal let currency: String

    /// Identifier of the chat, containing the corresponding invoice message; 0 if unknown
    internal let invoiceChatId: Int64

    /// Identifier of the message with the corresponding invoice; can be an identifier of a deleted message
    internal let invoiceMessageId: Int64

    /// Total price for the product, in the smallest units of the currency
    internal let totalAmount: Int64

    internal init(
        currency: String,
        invoiceChatId: Int64,
        invoiceMessageId: Int64,
        totalAmount: Int64
    ) {
        self.currency = currency
        self.invoiceChatId = invoiceChatId
        self.invoiceMessageId = invoiceMessageId
        self.totalAmount = totalAmount
    }
}

/// A payment has been completed; for bots only
internal struct MessagePaymentSuccessfulBot: Codable {
    /// Currency for price of the product
    internal let currency: String

    /// Invoice payload
    internal let invoicePayload: Data

    /// Information about the order; may be null
    internal let orderInfo: OrderInfo?

    /// Provider payment identifier
    internal let providerPaymentChargeId: String

    /// Identifier of the shipping option chosen by the user; may be empty if not applicable
    internal let shippingOptionId: String

    /// Telegram payment identifier
    internal let telegramPaymentChargeId: String

    /// Total price for the product, in the smallest units of the currency
    internal let totalAmount: Int64

    internal init(
        currency: String,
        invoicePayload: Data,
        orderInfo: OrderInfo?,
        providerPaymentChargeId: String,
        shippingOptionId: String,
        telegramPaymentChargeId: String,
        totalAmount: Int64
    ) {
        self.currency = currency
        self.invoicePayload = invoicePayload
        self.orderInfo = orderInfo
        self.providerPaymentChargeId = providerPaymentChargeId
        self.shippingOptionId = shippingOptionId
        self.telegramPaymentChargeId = telegramPaymentChargeId
        self.totalAmount = totalAmount
    }
}

/// The current user has connected a website by logging in using Telegram Login Widget on it
internal struct MessageWebsiteConnected: Codable {
    /// Domain name of the connected website
    internal let domainName: String

    internal init(domainName: String) {
        self.domainName = domainName
    }
}

/// Telegram Passport data has been sent
internal struct MessagePassportDataSent: Codable {
    /// List of Telegram Passport element types sent
    internal let types: [PassportElementType]

    internal init(types: [PassportElementType]) {
        self.types = types
    }
}

/// Telegram Passport data has been received; for bots only
internal struct MessagePassportDataReceived: Codable {
    /// Encrypted data credentials
    internal let credentials: EncryptedCredentials

    /// List of received Telegram Passport elements
    internal let elements: [EncryptedPassportElement]

    internal init(
        credentials: EncryptedCredentials,
        elements: [EncryptedPassportElement]
    ) {
        self.credentials = credentials
        self.elements = elements
    }
}

/// A user in the chat came within proximity alert range
internal struct MessageProximityAlertTriggered: Codable {
    /// The distance between the users
    internal let distance: Int

    /// The user or chat, which triggered the proximity alert
    internal let traveler: MessageSender

    /// The user or chat, which subscribed for the proximity alert
    internal let watcher: MessageSender

    internal init(
        distance: Int,
        traveler: MessageSender,
        watcher: MessageSender
    ) {
        self.distance = distance
        self.traveler = traveler
        self.watcher = watcher
    }
}
