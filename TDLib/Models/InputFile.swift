//
//  InputFile.swift
//  tl2swift
//
//  Created by Code Generator
//

import Foundation

/// Points to a file
internal enum InputFile: Codable {
    /// A file defined by its unique ID
    case inputFileId(InputFileId)

    /// A file defined by its remote ID. The remote ID is guaranteed to be usable only if the corresponding file is still accessible to the user and known to TDLib. For example, if the file is from a message, then the message must be not deleted and accessible to the user. If the file database is disabled, then the corresponding object with the file must be preloaded by the application
    case inputFileRemote(InputFileRemote)

    /// A file defined by a local path
    case inputFileLocal(InputFileLocal)

    /// A file generated by the application
    case inputFileGenerated(InputFileGenerated)

    private enum Kind: String, Codable {
        case inputFileId
        case inputFileRemote
        case inputFileLocal
        case inputFileGenerated
    }

    internal init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: DtoCodingKeys.self)
        let type = try container.decode(Kind.self, forKey: .type)
        switch type {
        case .inputFileId:
            let value = try InputFileId(from: decoder)
            self = .inputFileId(value)
        case .inputFileRemote:
            let value = try InputFileRemote(from: decoder)
            self = .inputFileRemote(value)
        case .inputFileLocal:
            let value = try InputFileLocal(from: decoder)
            self = .inputFileLocal(value)
        case .inputFileGenerated:
            let value = try InputFileGenerated(from: decoder)
            self = .inputFileGenerated(value)
        }
    }

    internal func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: DtoCodingKeys.self)
        switch self {
        case let .inputFileId(value):
            try container.encode(Kind.inputFileId, forKey: .type)
            try value.encode(to: encoder)
        case let .inputFileRemote(value):
            try container.encode(Kind.inputFileRemote, forKey: .type)
            try value.encode(to: encoder)
        case let .inputFileLocal(value):
            try container.encode(Kind.inputFileLocal, forKey: .type)
            try value.encode(to: encoder)
        case let .inputFileGenerated(value):
            try container.encode(Kind.inputFileGenerated, forKey: .type)
            try value.encode(to: encoder)
        }
    }
}

/// A file defined by its unique ID
internal struct InputFileId: Codable {
    /// Unique file identifier
    internal let id: Int

    internal init(id: Int) {
        self.id = id
    }
}

/// A file defined by its remote ID. The remote ID is guaranteed to be usable only if the corresponding file is still accessible to the user and known to TDLib. For example, if the file is from a message, then the message must be not deleted and accessible to the user. If the file database is disabled, then the corresponding object with the file must be preloaded by the application
internal struct InputFileRemote: Codable {
    /// Remote file identifier
    internal let id: String

    internal init(id: String) {
        self.id = id
    }
}

/// A file defined by a local path
internal struct InputFileLocal: Codable {
    /// Local path to the file
    internal let path: String

    internal init(path: String) {
        self.path = path
    }
}

/// A file generated by the application
internal struct InputFileGenerated: Codable {
    /// String specifying the conversion applied to the original file; should be persistent across application restarts. Conversions beginning with '#' are reserved for internal TDLib usage
    internal let conversion: String

    /// Expected size of the generated file; 0 if unknown
    internal let expectedSize: Int

    /// Local path to a file from which the file is generated; may be empty if there is no such file
    internal let originalPath: String

    internal init(
        conversion: String,
        expectedSize: Int,
        originalPath: String
    ) {
        self.conversion = conversion
        self.expectedSize = expectedSize
        self.originalPath = originalPath
    }
}
